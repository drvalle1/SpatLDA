sd1.new=ifelse(tmp<0,-tmp,tmp)
#get deltas
delta.old=get.delta(sig2=sd1.old^2,dist1=dist1)
delta.new=get.delta(sig2=sd1.new^2,dist1=dist1)
ldelta.old.theta=log(delta.old%*%theta)
ldelta.new.theta=log(delta.new%*%theta)
dim(ldelta.old.theta)
ngrid
array.soma=apply(array.gskp,c(1,3),sum)
#propose new values
sd1.old=sqrt(sig2)
tmp=rnorm(1,mean=sd1.old,sd=jump.sd)
sd1.new=ifelse(tmp<0,-tmp,tmp)
#get deltas
delta.old=get.delta(sig2=sd1.old^2,dist1=dist1)
delta.new=get.delta(sig2=sd1.new^2,dist1=dist1)
ldelta.old.theta=log(delta.old%*%theta)
ldelta.new.theta=log(delta.new%*%theta)
p.old=p.new=0
dim(array.soma)
#summarize array
array.soma=apply(array.gskp,c(1,3),sum)
#propose new values
sd1.old=sqrt(sig2)
tmp=rnorm(1,mean=sd1.old,sd=jump.sd)
sd1.new=ifelse(tmp<0,-tmp,tmp)
#get deltas
delta.old=get.delta(sig2=sd1.old^2,dist1=dist1)
delta.new=get.delta(sig2=sd1.new^2,dist1=dist1)
ldelta.old.theta=log(delta.old%*%theta)
ldelta.new.theta=log(delta.new%*%theta)
p.old=p.new=0
for (i in 1:ngrid){
for (j in 1:nclust){
if (array.soma[i,j]>0){
p.old=p.old+array.soma[i,j]*ldelta.old.theta[i,j]
p.new=p.new+array.soma[i,j]*ldelta.new.theta[i,j]
}
}
}
cond=is.na(p.new) #this happens when sd is very small and we divide by zero in get.delta()
if (cond)  tmp=0
if (!cond) tmp=exp(p.new-p.old)
sd1=sd1.old
accept1=0
if (runif(1)<tmp) {sd1=sd1.new; accept1=1}
list(sig2=sd1^2,accept1=accept1)
tmp=sample.sig2(dist1=dist1,sig2=sig2,theta=theta,jump.sd=jump.sd,
ngrid=ngrid,nclust=nclust,array.gskp=array.gskp)
rm(list=ls(all=TRUE))
library('gtools')
set.seed(1)
#get functions
setwd('U:\\GIT_models\\SpatLDA')
source('SpatLDA aux functions.R')
#get data
setwd('U:\\GIT_models\\SpatLDA\\fake data')
dat0=dat=read.csv('fake data1.csv',as.is=T)
#potential documents
coord.plot=expand.grid(x=seq(from=0,to=1000,by=200),
y=seq(from=0,to=1000,by=200))
nplot=nrow(coord.plot)
#useful stuff
nclust=3
ngibbs=1000
nburn=ngibbs/2
#priors
gamma.theta=0.1
gamma.phi=0.1
#useful stuff
ngrid=nrow(dat)
ind=grep('spp',colnames(dat))
tmp=colnames(dat)[ind]
tmp1=as.numeric(gsub('spp','',tmp))
nspp=max(tmp1)
#get distances
dist1=matrix(NA,ngrid,nplot)
for (i in 1:nplot){
x2=(dat$xbin-coord.plot$x[i])^2
y2=(dat$ybin-coord.plot$y[i])^2
dist1[,i]=sqrt(x2+y2)
}
#initial values for parameters
theta=matrix(1/nclust,nplot,nclust)
phi=matrix(1/nspp,nclust,nspp)
sig2=100
delta=get.delta(sig2=sig2,dist1=dist1)
#initial values for cluster and plot membership
array.gskp=array(0,dim=c(ngrid,nspp,nclust,nplot))
nbins=nclust*nplot
for (i in 1:ngrid){
for (j in 1:nspp){
tmp=dat[i,paste0('spp',j)]
if (tmp>0){
tmp1=rmultinom(1,size=tmp,prob=rep(1/nbins,nbins))
array.gskp[i,j,,]=matrix(tmp1,nclust,nplot)
}
}
}
# teste=apply(array.gskp,c(1,2),sum)
# unique(teste-dat[,paste0('spp',1:nspp)])
#MH stuff
jump.sd=1
accept1=0
nchange.jump=50
#to store outcomes from gibbs sampler
theta.out=matrix(NA,ngibbs,nclust*nplot)
phi.out=matrix(NA,ngibbs,nclust*nspp)
sig2.out=matrix(NA,ngibbs,1)
llk=rep(NA,ngibbs)
#run gibbs sampler
options(warn=2)
array.gskp=sample.clust.id(theta=theta,phi=phi,nplot=nplot,nspp=nspp,
array.gskp=array.gskp)
#sample plot.id
array.gskp=sample.plot.id(theta=theta,delta=delta,array.gskp=array.gskp,
ngrid=ngrid,nspp=nspp,nclust=nclust)
#sample theta
theta=sample.theta(array.gskp=array.gskp,nplot=nplot,nclust=nclust,gamma1.theta=gamma.theta)
# theta=theta.true
#sample phi
phi=sample.phi(array.gskp=array.gskp,gamma1.phi=gamma.phi,nclust=nclust,nspp=nspp)
# phi=phi.true
#sample sig2
tmp=sample.sig2(dist1=dist1,sig2=sig2,theta=theta,jump.sd=jump.sd,
ngrid=ngrid,nclust=nclust,array.gskp=array.gskp)
accept1=accept1+tmp$accept1
sig2=tmp$sig2
# sig2=sig2.true
delta=get.delta(sig2=sig2,dist1=dist1)
prob=matrix(NA,ngrid,nspp)
for (i in 1:ngrid){
for (j in 1:nspp){
tmp=delta[i,]%*%theta%*%phi[,j]
llk[i]=log(tmp)
}
}
rm(list=ls(all=TRUE))
library('gtools')
set.seed(1)
#get functions
setwd('U:\\GIT_models\\SpatLDA')
source('SpatLDA aux functions.R')
#get data
setwd('U:\\GIT_models\\SpatLDA\\fake data')
dat0=dat=read.csv('fake data1.csv',as.is=T)
#potential documents
coord.plot=expand.grid(x=seq(from=0,to=1000,by=200),
y=seq(from=0,to=1000,by=200))
nplot=nrow(coord.plot)
#useful stuff
nclust=3
ngibbs=1000
nburn=ngibbs/2
#priors
gamma.theta=0.1
gamma.phi=0.1
#useful stuff
ngrid=nrow(dat)
ind=grep('spp',colnames(dat))
nomes.spp=colnames(dat)[ind]
tmp1=as.numeric(gsub('spp','',nomes.spp))
nspp=max(tmp1)
#get distances
dist1=matrix(NA,ngrid,nplot)
for (i in 1:nplot){
x2=(dat$xbin-coord.plot$x[i])^2
y2=(dat$ybin-coord.plot$y[i])^2
dist1[,i]=sqrt(x2+y2)
}
#initial values for parameters
theta=matrix(1/nclust,nplot,nclust)
phi=matrix(1/nspp,nclust,nspp)
sig2=100
delta=get.delta(sig2=sig2,dist1=dist1)
#initial values for cluster and plot membership
array.gskp=array(0,dim=c(ngrid,nspp,nclust,nplot))
nbins=nclust*nplot
for (i in 1:ngrid){
for (j in 1:nspp){
tmp=dat[i,paste0('spp',j)]
if (tmp>0){
tmp1=rmultinom(1,size=tmp,prob=rep(1/nbins,nbins))
array.gskp[i,j,,]=matrix(tmp1,nclust,nplot)
}
}
}
# teste=apply(array.gskp,c(1,2),sum)
# unique(teste-dat[,paste0('spp',1:nspp)])
#MH stuff
jump.sd=1
accept1=0
nchange.jump=50
#to store outcomes from gibbs sampler
theta.out=matrix(NA,ngibbs,nclust*nplot)
phi.out=matrix(NA,ngibbs,nclust*nspp)
sig2.out=matrix(NA,ngibbs,1)
llk=rep(NA,ngibbs)
#run gibbs sampler
options(warn=2)
i=1
#sample clust.id
array.gskp=sample.clust.id(theta=theta,phi=phi,nplot=nplot,nspp=nspp,
array.gskp=array.gskp)
#sample plot.id
array.gskp=sample.plot.id(theta=theta,delta=delta,array.gskp=array.gskp,
ngrid=ngrid,nspp=nspp,nclust=nclust)
#sample theta
theta=sample.theta(array.gskp=array.gskp,nplot=nplot,nclust=nclust,gamma1.theta=gamma.theta)
# theta=theta.true
#sample phi
phi=sample.phi(array.gskp=array.gskp,gamma1.phi=gamma.phi,nclust=nclust,nspp=nspp)
# phi=phi.true
tmp=sample.sig2(dist1=dist1,sig2=sig2,theta=theta,jump.sd=jump.sd,
ngrid=ngrid,nclust=nclust,array.gskp=array.gskp)
accept1=accept1+tmp$accept1
sig2=tmp$sig2
# sig2=sig2.true
delta=get.delta(sig2=sig2,dist1=dist1)
#adapt MH
if (i%%nchange.jump==0 & i<nburn){
if (accept1/nchange.jump < 0.1) jump.sd=jump.sd*0.5
if (accept1/nchange.jump > 0.6) jump.sd=jump.sd*2
accept1=0
}
#llk
llk[i]=get.llk(dat=dat,delta=delta,theta=theta,phi=phi,
ngrid=ngrid,nspp=nspp,nomes.spp=nomes.spp)
get.llk(dat=dat,delta=delta,theta=theta,phi=phi,
ngrid=ngrid,nspp=nspp,nomes.spp=nomes.spp)
rm(list=ls(all=TRUE))
library('gtools')
set.seed(1)
#get functions
setwd('U:\\GIT_models\\SpatLDA')
source('SpatLDA aux functions.R')
#get data
setwd('U:\\GIT_models\\SpatLDA\\fake data')
dat0=dat=read.csv('fake data1.csv',as.is=T)
#potential documents
coord.plot=expand.grid(x=seq(from=0,to=1000,by=200),
y=seq(from=0,to=1000,by=200))
nplot=nrow(coord.plot)
#useful stuff
nclust=3
ngibbs=1000
nburn=ngibbs/2
#priors
gamma.theta=0.1
gamma.phi=0.1
#useful stuff
ngrid=nrow(dat)
ind=grep('spp',colnames(dat))
nomes.spp=colnames(dat)[ind]
tmp1=as.numeric(gsub('spp','',nomes.spp))
nspp=max(tmp1)
#get distances
dist1=matrix(NA,ngrid,nplot)
for (i in 1:nplot){
x2=(dat$xbin-coord.plot$x[i])^2
y2=(dat$ybin-coord.plot$y[i])^2
dist1[,i]=sqrt(x2+y2)
}
#initial values for parameters
theta=matrix(1/nclust,nplot,nclust)
phi=matrix(1/nspp,nclust,nspp)
sig2=100
delta=get.delta(sig2=sig2,dist1=dist1)
#initial values for cluster and plot membership
array.gskp=array(0,dim=c(ngrid,nspp,nclust,nplot))
nbins=nclust*nplot
for (i in 1:ngrid){
for (j in 1:nspp){
tmp=dat[i,paste0('spp',j)]
if (tmp>0){
tmp1=rmultinom(1,size=tmp,prob=rep(1/nbins,nbins))
array.gskp[i,j,,]=matrix(tmp1,nclust,nplot)
}
}
}
# teste=apply(array.gskp,c(1,2),sum)
# unique(teste-dat[,paste0('spp',1:nspp)])
#MH stuff
jump.sd=1
accept1=0
nchange.jump=50
#to store outcomes from gibbs sampler
theta.out=matrix(NA,ngibbs,nclust*nplot)
phi.out=matrix(NA,ngibbs,nclust*nspp)
sig2.out=matrix(NA,ngibbs,1)
llk=rep(NA,ngibbs)
#run gibbs sampler
options(warn=2)
array.gskp=sample.clust.id(theta=theta,phi=phi,nplot=nplot,nspp=nspp,
array.gskp=array.gskp)
#sample plot.id
array.gskp=sample.plot.id(theta=theta,delta=delta,array.gskp=array.gskp,
ngrid=ngrid,nspp=nspp,nclust=nclust)
#sample theta
theta=sample.theta(array.gskp=array.gskp,nplot=nplot,nclust=nclust,gamma1.theta=gamma.theta)
# theta=theta.true
#sample phi
phi=sample.phi(array.gskp=array.gskp,gamma1.phi=gamma.phi,nclust=nclust,nspp=nspp)
# phi=phi.true
#sample sig2
tmp=sample.sig2(dist1=dist1,sig2=sig2,theta=theta,jump.sd=jump.sd,
ngrid=ngrid,nclust=nclust,array.gskp=array.gskp)
accept1=accept1+tmp$accept1
sig2=tmp$sig2
# sig2=sig2.true
delta=get.delta(sig2=sig2,dist1=dist1)
#adapt MH
if (i%%nchange.jump==0 & i<nburn){
if (accept1/nchange.jump < 0.1) jump.sd=jump.sd*0.5
if (accept1/nchange.jump > 0.6) jump.sd=jump.sd*2
accept1=0
}
get.llk(dat=dat,delta=delta,theta=theta,phi=phi,
ngrid=ngrid,nspp=nspp,nomes.spp=nomes.spp)
rm(list=ls(all=TRUE))
library('gtools')
set.seed(1)
#get functions
setwd('U:\\GIT_models\\SpatLDA')
source('SpatLDA aux functions.R')
#get data
setwd('U:\\GIT_models\\SpatLDA\\fake data')
dat0=dat=read.csv('fake data1.csv',as.is=T)
#potential documents
coord.plot=expand.grid(x=seq(from=0,to=1000,by=200),
y=seq(from=0,to=1000,by=200))
nplot=nrow(coord.plot)
#useful stuff
nclust=3
ngibbs=1000
nburn=ngibbs/2
#priors
gamma.theta=0.1
gamma.phi=0.1
#useful stuff
ngrid=nrow(dat)
ind=grep('spp',colnames(dat))
nomes.spp=colnames(dat)[ind]
tmp1=as.numeric(gsub('spp','',nomes.spp))
nspp=max(tmp1)
#get distances
dist1=matrix(NA,ngrid,nplot)
for (i in 1:nplot){
x2=(dat$xbin-coord.plot$x[i])^2
y2=(dat$ybin-coord.plot$y[i])^2
dist1[,i]=sqrt(x2+y2)
}
#initial values for parameters
theta=matrix(1/nclust,nplot,nclust)
phi=matrix(1/nspp,nclust,nspp)
sig2=100
delta=get.delta(sig2=sig2,dist1=dist1)
#initial values for cluster and plot membership
array.gskp=array(0,dim=c(ngrid,nspp,nclust,nplot))
nbins=nclust*nplot
for (i in 1:ngrid){
for (j in 1:nspp){
tmp=dat[i,paste0('spp',j)]
if (tmp>0){
tmp1=rmultinom(1,size=tmp,prob=rep(1/nbins,nbins))
array.gskp[i,j,,]=matrix(tmp1,nclust,nplot)
}
}
}
# teste=apply(array.gskp,c(1,2),sum)
# unique(teste-dat[,paste0('spp',1:nspp)])
#MH stuff
jump.sd=1
accept1=0
nchange.jump=50
#to store outcomes from gibbs sampler
theta.out=matrix(NA,ngibbs,nclust*nplot)
phi.out=matrix(NA,ngibbs,nclust*nspp)
sig2.out=matrix(NA,ngibbs,1)
llk=rep(NA,ngibbs)
#run gibbs sampler
options(warn=2)
for (i in 1:ngibbs){
print(i)
#sample clust.id
array.gskp=sample.clust.id(theta=theta,phi=phi,nplot=nplot,nspp=nspp,
array.gskp=array.gskp)
#sample plot.id
array.gskp=sample.plot.id(theta=theta,delta=delta,array.gskp=array.gskp,
ngrid=ngrid,nspp=nspp,nclust=nclust)
#sample theta
theta=sample.theta(array.gskp=array.gskp,nplot=nplot,nclust=nclust,gamma1.theta=gamma.theta)
# theta=theta.true
#sample phi
phi=sample.phi(array.gskp=array.gskp,gamma1.phi=gamma.phi,nclust=nclust,nspp=nspp)
# phi=phi.true
#sample sig2
tmp=sample.sig2(dist1=dist1,sig2=sig2,theta=theta,jump.sd=jump.sd,
ngrid=ngrid,nclust=nclust,array.gskp=array.gskp)
accept1=accept1+tmp$accept1
sig2=tmp$sig2
# sig2=sig2.true
delta=get.delta(sig2=sig2,dist1=dist1)
#adapt MH
if (i%%nchange.jump==0 & i<nburn){
if (accept1/nchange.jump < 0.1) jump.sd=jump.sd*0.5
if (accept1/nchange.jump > 0.6) jump.sd=jump.sd*2
accept1=0
}
#llk
llk[i]=get.llk(dat=dat,delta=delta,theta=theta,phi=phi,
ngrid=ngrid,nspp=nspp,nomes.spp=nomes.spp)
#store results
theta.out[i,]=theta
phi.out[i,]=phi
sig2.out[i]=sig2
}
rm(list=ls())
library('ggplot2')
set.seed(3)
#trees
ntrees=10000
coord=data.frame(x=runif(ntrees,min=0,max=1000),
y=runif(ntrees,min=0,max=1000))
#documents
ndoc=3
coord.doc=data.frame(x=c(200,600,800),
y=c(200,400,800))
plot(y~x,data=coord)
points(y~x,data=coord.doc,col='red',pch=19)
#theta for each doc
nclust=3
theta=matrix(c(0.05,0.05,0.9,
0.05,0.9,0.05,
0.8,0.1,0.1),ndoc,nclust,byrow=T)
theta.true=theta
# apply(theta,1,sum)
#phi for each cluster
nspp=50
tmp=rbeta(nspp*nclust,0.1,0.1)
ind=sample(1:(nspp*nclust),size=25)
tmp[ind]=4
tmp1=matrix(tmp,nclust,nspp)
phi=tmp1/apply(tmp1,1,sum)
phi.true=phi
# head(round(phi[,1:10],3))
# hist(phi[5,])
#get distance from each document to each tree
dist1=matrix(NA,ntrees,ndoc)
for (i in 1:ndoc){
x2=(coord$x-coord.doc$x[i])^2
y2=(coord$y-coord.doc$y[i])^2
dist1[,i]=sqrt(x2+y2)
}
#get cluster membership for each tree
sig2=sig2.true=20
for (i in 1:ntrees){
#which document?
prob=exp(-(1/(2*sig2))*dist1[i,])
tmp=rmultinom(1,size=1,prob=prob/sum(prob))
ind=which(tmp==1)
coord$omega[i]=ind
#which cluster?
tmp=rmultinom(1,size=1,prob=theta[ind,])
ind=which(tmp==1)
coord$psi[i]=ind
#which species?
tmp=rmultinom(1,size=1,prob=phi[ind,])
ind=which(tmp==1)
coord$spp[i]=ind
}
#spatial distribution of communities
plot(y~x,data=coord,col=coord$psi,pch=19)
plot(y~x,data=coord,col=coord$omega,pch=19)
#export results
setwd('U:\\GIT_models\\SpatLDA\\fake data')
coord=expand.grid(x=seq(from=0,to=1000,by=10),
y=seq(from=0,to=1000,by=10))
ncoord=nrow(coord)
#get distances
dist1=matrix(NA,ncoord,ndoc)
for (i in 1:ndoc){
x2=(coord$x-coord.doc$x[i])^2
y2=(coord$y-coord.doc$y[i])^2
dist1[,i]=sqrt(x2+y2)
}
#calculate probabilities
res=matrix(NA,ncoord,nclust)
for (i in 1:ncoord){
tmp=exp(-(1/(2*sig2))*dist1[i,])
delta=tmp/sum(tmp)
for (j in 1:nclust){
res[i,j]=sum(theta[,j]*delta)
}
}
#create final data.frame with prob for each cluster
colnames(res)=paste0('c',1:nclust)
res1=as.data.frame(res)
coord1=cbind(coord,res1)
#plot results
library(gridExtra)
library(grid)
p1=ggplot() +
geom_tile(data = coord1, alpha = 0.8,aes(x = x, y = y,fill = c1)) +
scale_fill_gradient2(low = "cyan", mid = "red",high='purple',limits=c(0,1),midpoint=0.5)
p2=ggplot() +
geom_tile(data = coord1, alpha = 0.8,aes(x = x, y = y,fill = c2)) +
scale_fill_gradient2(low = "cyan", mid = "red",high='purple',limits=c(0,1),midpoint=0.5)
p3=ggplot() +
geom_tile(data = coord1, alpha = 0.8,aes(x = x, y = y,fill = c3)) +
scale_fill_gradient2(low = "cyan", mid = "red",high='purple',limits=c(0,1),midpoint=0.5)
grid.arrange(p1, p2, p3,nrow = 1)
